#nullable enable
Funcky.DataTypes.EitherOrBoth<TLeft, TRight>
Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Equals(Funcky.DataTypes.EitherOrBoth<TLeft, TRight> other) -> bool
Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Match(System.Action<TLeft>! left, System.Action<TRight>! right, System.Action<TLeft, TRight>! both) -> void
Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Match<TMatchResult>(System.Func<TLeft, TMatchResult>! left, System.Func<TRight, TMatchResult>! right, System.Func<TLeft, TRight, TMatchResult>! both) -> TMatchResult
Funcky.Extensions.FunctionCompositionExtensions
Funcky.Monads.Either<TLeft, TRight>.Match(System.Action<TLeft>! left, System.Action<TRight>! right) -> void
Funcky.Monads.Factory
Funcky.Monads.FuncExtensions
Funcky.Monads.Io<T>
Funcky.Monads.IoExtensions
Funcky.Monads.State<TState, T>
Funcky.Monads.StateExtensions
override Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Equals(object? obj) -> bool
override Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.GetHashCode() -> int
static Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Both(TLeft left, TRight right) -> Funcky.DataTypes.EitherOrBoth<TLeft, TRight>
static Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Left(TLeft left) -> Funcky.DataTypes.EitherOrBoth<TLeft, TRight>
static Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.Right(TRight right) -> Funcky.DataTypes.EitherOrBoth<TLeft, TRight>
static Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.operator !=(Funcky.DataTypes.EitherOrBoth<TLeft, TRight> lhs, Funcky.DataTypes.EitherOrBoth<TLeft, TRight> rhs) -> bool
static Funcky.DataTypes.EitherOrBoth<TLeft, TRight>.operator ==(Funcky.DataTypes.EitherOrBoth<TLeft, TRight> lhs, Funcky.DataTypes.EitherOrBoth<TLeft, TRight> rhs) -> bool
static Funcky.Extensions.DictionaryExtensions.GetValueOrNone<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue>! dictionary, TKey key) -> Funcky.Monads.Option<TValue>
static Funcky.Extensions.DictionaryExtensions.GetValueOrNone<TKey, TValue>(this System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>! dictionary, TKey readOnlyKey) -> Funcky.Monads.Option<TValue>
static Funcky.Extensions.EnumerableExtensions.PowerSet<TSource>(this System.Collections.Generic.IEnumerable<TSource>! source) -> System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<TSource>!>!
static Funcky.Extensions.EnumerableExtensions.Shuffle<TSource>(this System.Collections.Generic.IEnumerable<TSource>! source) -> System.Collections.Generic.IEnumerable<TSource>!
static Funcky.Extensions.EnumerableExtensions.ZipLongest<TLeft, TRight, TResult>(this System.Collections.Generic.IEnumerable<TLeft>! left, System.Collections.Generic.IEnumerable<TRight>! right, System.Func<Funcky.DataTypes.EitherOrBoth<TLeft, TRight>, TResult>! resultSelector) -> System.Collections.Generic.IEnumerable<TResult>!
static Funcky.Extensions.EnumerableExtensions.ZipLongest<TLeft, TRight>(this System.Collections.Generic.IEnumerable<TLeft>! left, System.Collections.Generic.IEnumerable<TRight>! right) -> System.Collections.Generic.IEnumerable<Funcky.DataTypes.EitherOrBoth<TLeft, TRight>>!
static Funcky.Extensions.FunctionCompositionExtensions.Compose<TInput, TIntermediate, TOutput>(this System.Func<TIntermediate, TOutput>! f, System.Func<TInput, TIntermediate>! g) -> System.Func<TInput, TOutput>!
static Funcky.Extensions.FunctionCompositionExtensions.Compose<TInput, TIntermediate>(this System.Action<TIntermediate>! f, System.Func<TInput, TIntermediate>! g) -> System.Action<TInput>!
static Funcky.Extensions.FunctionCompositionExtensions.Compose<TIntermediate, TOutput>(this System.Func<TIntermediate, TOutput>! f, System.Func<TIntermediate>! g) -> System.Func<TOutput>!
static Funcky.Extensions.FunctionCompositionExtensions.Compose<TIntermediate>(this System.Action<TIntermediate>! f, System.Func<TIntermediate>! g) -> System.Action!
static Funcky.Extensions.HttpHeadersExtensions.GetValuesOrNone(this System.Net.Http.Headers.HttpHeaders! headers, string! name) -> Funcky.Monads.Option<System.Collections.Generic.IEnumerable<string!>!>
static Funcky.Extensions.ParseExtensions.ParseBooleanOrNone(this string! candidate) -> Funcky.Monads.Option<bool>
static Funcky.Extensions.ParseExtensions.ParseByteOrNone(this string! candidate) -> Funcky.Monads.Option<byte>
static Funcky.Extensions.ParseExtensions.ParseByteOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<byte>
static Funcky.Extensions.ParseExtensions.ParseDateTimeOrNone(this string! candidate) -> Funcky.Monads.Option<System.DateTime>
static Funcky.Extensions.ParseExtensions.ParseDateTimeOrNone(this string! candidate, System.IFormatProvider! provider, System.Globalization.DateTimeStyles styles) -> Funcky.Monads.Option<System.DateTime>
static Funcky.Extensions.ParseExtensions.ParseDecimalOrNone(this string! candidate) -> Funcky.Monads.Option<decimal>
static Funcky.Extensions.ParseExtensions.ParseDecimalOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<decimal>
static Funcky.Extensions.ParseExtensions.ParseDoubleOrNone(this string! candidate) -> Funcky.Monads.Option<double>
static Funcky.Extensions.ParseExtensions.ParseDoubleOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<double>
static Funcky.Extensions.ParseExtensions.ParseEnumOrNone<TEnum>(this string! candidate) -> Funcky.Monads.Option<TEnum>
static Funcky.Extensions.ParseExtensions.ParseEnumOrNone<TEnum>(this string! candidate, bool ignoreCase) -> Funcky.Monads.Option<TEnum>
static Funcky.Extensions.ParseExtensions.ParseFloatOrNone(this string! candidate) -> Funcky.Monads.Option<float>
static Funcky.Extensions.ParseExtensions.ParseFloatOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<float>
static Funcky.Extensions.ParseExtensions.ParseIntOrNone(this string! candidate) -> Funcky.Monads.Option<int>
static Funcky.Extensions.ParseExtensions.ParseIntOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<int>
static Funcky.Extensions.ParseExtensions.ParseLongOrNone(this string! candidate) -> Funcky.Monads.Option<long>
static Funcky.Extensions.ParseExtensions.ParseLongOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<long>
static Funcky.Extensions.ParseExtensions.ParseShortOrNone(this string! candidate) -> Funcky.Monads.Option<short>
static Funcky.Extensions.ParseExtensions.ParseShortOrNone(this string! candidate, System.Globalization.NumberStyles styles, System.IFormatProvider! provider) -> Funcky.Monads.Option<short>
static Funcky.Extensions.ParseExtensions.ParseTimeSpanOrNone(this string! candidate) -> Funcky.Monads.Option<System.TimeSpan>
static Funcky.Extensions.ParseExtensions.ParseTimeSpanOrNone(this string! candidate, System.IFormatProvider! provider) -> Funcky.Monads.Option<System.TimeSpan>
static Funcky.Extensions.StringExtensions.SplitLazy(this string! text, char separator) -> System.Collections.Generic.IEnumerable<string!>!
static Funcky.Extensions.StringExtensions.SplitLazy(this string! text, params char[]! separators) -> System.Collections.Generic.IEnumerable<string!>!
static Funcky.Extensions.StringExtensions.SplitLazy(this string! text, params string![]! separators) -> System.Collections.Generic.IEnumerable<string!>!
static Funcky.Extensions.StringExtensions.SplitLazy(this string! text, string! separator) -> System.Collections.Generic.IEnumerable<string!>!
static Funcky.Extensions.StringExtensions.SplitLines(this string! text) -> System.Collections.Generic.IEnumerable<string!>!
static Funcky.Functional.False<T0, T1>(T0 ω0, T1 ω1) -> bool
static Funcky.Functional.True<T0, T1>(T0 ω0, T1 ω1) -> bool
static Funcky.Monads.Factory.Func(System.Action! action) -> System.Func<Funcky.Unit>!
static Funcky.Monads.Factory.Func<TResult>(System.Func<TResult>! function) -> System.Func<TResult>!
static Funcky.Monads.Factory.GetState<TState>() -> Funcky.Monads.State<TState, TState>!
static Funcky.Monads.Factory.Io(System.Action! action) -> Funcky.Monads.Io<Funcky.Unit>!
static Funcky.Monads.Factory.Io<TResult>(System.Func<TResult>! function) -> Funcky.Monads.Io<TResult>!
static Funcky.Monads.Factory.SetState<TState>(TState newState) -> Funcky.Monads.State<TState, Funcky.Unit>!
static Funcky.Monads.FuncExtensions.Func<TSource>(this TSource value) -> System.Func<TSource>!
static Funcky.Monads.FuncExtensions.Select<TSource, TResult>(this System.Func<TSource>! source, System.Func<TSource, TResult>! selector) -> System.Func<TResult>!
static Funcky.Monads.FuncExtensions.SelectMany<TSource, TSelector, TResult>(this System.Func<TSource>! source, System.Func<TSource, System.Func<TSelector>!>! selector, System.Func<TSource, TSelector, TResult>! resultSelector) -> System.Func<TResult>!
static Funcky.Monads.IoExtensions.Io<TSource>(this TSource value) -> Funcky.Monads.Io<TSource>!
static Funcky.Monads.IoExtensions.Select<TSource, TResult>(this Funcky.Monads.Io<TSource>! source, System.Func<TSource, TResult>! selector) -> Funcky.Monads.Io<TResult>!
static Funcky.Monads.IoExtensions.SelectMany<TSource, TSelector, TResult>(this Funcky.Monads.Io<TSource>! source, System.Func<TSource, Funcky.Monads.Io<TSelector>!>! selector, System.Func<TSource, TSelector, TResult>! resultSelector) -> Funcky.Monads.Io<TResult>!
static Funcky.Monads.Option<TItem>.implicit operator Funcky.Monads.Option<TItem>(TItem item) -> Funcky.Monads.Option<TItem>
static Funcky.Monads.StateExtensions.Select<TState, TSource, TResult>(this Funcky.Monads.State<TState, TSource>! source, System.Func<TSource, TResult>! selector) -> Funcky.Monads.State<TState, TResult>!
static Funcky.Monads.StateExtensions.SelectMany<TState, TSource, TSelector, TResult>(this Funcky.Monads.State<TState, TSource>! source, System.Func<TSource, Funcky.Monads.State<TState, TSelector>!>! selector, System.Func<TSource, TSelector, TResult>! resultSelector) -> Funcky.Monads.State<TState, TResult>!
static Funcky.Monads.StateExtensions.State<TState, TSource>(this TSource value) -> Funcky.Monads.State<TState, TSource>!
static Funcky.Sequence.Cycle<TItem>(TItem element) -> System.Collections.Generic.IEnumerable<TItem>!
static Funcky.Sequence.CycleRange<TItem>(System.Collections.Generic.IEnumerable<TItem>! sequence) -> System.Collections.Generic.IEnumerable<TItem>!
static Funcky.Sequence.RepeatRange<TItem>(System.Collections.Generic.IEnumerable<TItem>! sequence, int count) -> System.Collections.Generic.IEnumerable<TItem>!
Funcky.Monads.OptionEqualityComparer
Funcky.Monads.OptionEqualityComparer<TItem>
static Funcky.Monads.OptionEqualityComparer.Create<TItem>(System.Collections.Generic.IEqualityComparer<TItem>! comparer) -> System.Collections.Generic.EqualityComparer<Funcky.Monads.Option<TItem>>!
static Funcky.Monads.OptionEqualityComparer<TItem>.Default.get -> System.Collections.Generic.EqualityComparer<Funcky.Monads.Option<TItem>>!
static Funcky.Functional.True() -> bool
static Funcky.Functional.False() -> bool
static Funcky.Sequence.Concat<TSource>(System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<TSource>!>! sources) -> System.Collections.Generic.IEnumerable<TSource>!
static Funcky.Sequence.Concat<TSource>(params System.Collections.Generic.IEnumerable<TSource>![]! sources) -> System.Collections.Generic.IEnumerable<TSource>!
